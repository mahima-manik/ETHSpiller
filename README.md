# ETHSpitter

## ETHSplitter contract

**Data members**
1. Owner's address
2. List of recepient's addresses
3. Mapping of addresses to the indexes

**Functions**
1. addRecepient(), removeRecepient(): can be called once for every address. Access: onlyOwner
2. receiveEther(): to receive and distribute ether among the recepients. 


1. Address of the owner is immutable. Benefits - 
    - cannot be changed by attacker after contract creation
    - Saves gas
2. Recepients are stored in the dynamic list & their indexes in the list is stored as mapping. Reasons:
    - Iterating maps in Solidity is not possible
    - Map is easier to check whether the address exists in the list.
3. Modifiers are added to add access control on the functions.
4. Custom errors are defined in all contracts. They are cheaper to use than *require + error messages*.

**Edge cases**
1. Ether can also be received by the contract when no recepient is present. 

## Lottery Contract

Explain the sequence of events that must happen on-chain, their timing, and the parameters that must be passed to the methods. Explain why your strategy is secure and generates a good random number.

```
mapping (address => bool) tickets;
uint immutable ticketPrice;
bool started = false;
event Winner(address account);

constructor (uint _price) {
    // set ticketPrice
    // initialize the contract with 100 ETH
    started = true;
}

function buyTicket() external payable;
function draw() external onlyOwner payable;
```

1. Lottery contract must be deployed with 100 ETH deposited to it for lottery to begin.
2. Lottery contract address will initially hold 100 ETH
3. One address should be set as the *owner*. 
4. Owner should set the ticket price
5. Only owner should only be allowed to call draw() method.
6. Any address can call buyTicket() method by passing the ticket price as *msg.value*. buyTicket
7. Ticket prices can either go to - owner of the contract or stay with contract address (depends on use case).
8. draw() can be called by owner of the contract - chooses winner by generating a random number, transfers 100ETH to the winner & set `started = false`.

**Random number generation inside smart contract:**

In solidity, we cannot truly generate "random number", because the contract has to be deterministic. Each node computing the function should get the same function output, to validate the transaction and hence reach the consensus.

1. Since we cannot use any external API inside the smart contract, random number is generated by variables available inside the contract: https://docs.soliditylang.org/en/v0.4.21/units-and-global-variables.html#block-and-transaction-properties.

Using arithermatic operations on these variables and applying modulus to the output, pseudo-random number can be generated in the function.